{"ast":null,"code":"// Function to record audio using the Web Audio API\nexport const recordAudio = () => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const mediaRecorder = new MediaRecorder(stream);\n      const audioChunks = [];\n      mediaRecorder.addEventListener('dataavailable', event => {\n        audioChunks.push(event.data);\n      });\n      mediaRecorder.addEventListener('stop', () => {\n        const audioBlob = new Blob(audioChunks, {\n          type: 'audio/wav'\n        });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        resolve({\n          audioBlob,\n          audioUrl\n        });\n      });\n      mediaRecorder.start();\n\n      // Stop recording after 10 seconds (for example)\n      setTimeout(() => {\n        mediaRecorder.stop();\n      }, 10000);\n    } catch (error) {\n      console.error('Error recording audio:', error);\n      reject(error);\n    }\n  });\n};\nexport const initializeAudioStream = async onDataAvailable => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    const mediaRecorder = new MediaRecorder(stream);\n    mediaRecorder.ondataavailable = event => {\n      if (event.data.size > 0) {\n        onDataAvailable(event.data);\n      }\n    };\n    mediaRecorder.start(1000); // Send chunks every 1 second\n    return {\n      stream,\n      mediaRecorder\n    };\n  } catch (error) {\n    throw new Error('Microphone access denied: ' + error.message);\n  }\n};\nexport const stopAudioStream = (mediaRecorder, stream) => {\n  if ((mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.state) === 'recording') {\n    mediaRecorder.stop();\n  }\n  stream === null || stream === void 0 ? void 0 : stream.getTracks().forEach(track => track.stop());\n};\n\n// Function to play audio\nexport const playAudio = audioUrl => {\n  const audio = new Audio(audioUrl);\n  audio.play();\n};\n\n// Function to convert audio Blob to Base64\nexport const audioBlobToBase64 = blob => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      resolve(reader.result.split(',')[1]); // Extract Base64 data\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n};","map":{"version":3,"names":["recordAudio","Promise","resolve","reject","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","audioChunks","addEventListener","event","push","data","audioBlob","Blob","type","audioUrl","URL","createObjectURL","start","setTimeout","stop","error","console","initializeAudioStream","onDataAvailable","ondataavailable","size","Error","message","stopAudioStream","state","getTracks","forEach","track","playAudio","Audio","play","audioBlobToBase64","blob","reader","FileReader","onloadend","result","split","onerror","readAsDataURL"],"sources":["C:/Users/Varun G/Documents/My_Projects/HackHive/src/utils/audioUtils.js"],"sourcesContent":["// Function to record audio using the Web Audio API\r\nexport const recordAudio = () => {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        const mediaRecorder = new MediaRecorder(stream);\r\n        const audioChunks = [];\r\n  \r\n        mediaRecorder.addEventListener('dataavailable', (event) => {\r\n          audioChunks.push(event.data);\r\n        });\r\n  \r\n        mediaRecorder.addEventListener('stop', () => {\r\n          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\r\n          const audioUrl = URL.createObjectURL(audioBlob);\r\n          resolve({ audioBlob, audioUrl });\r\n        });\r\n  \r\n        mediaRecorder.start();\r\n  \r\n        // Stop recording after 10 seconds (for example)\r\n        setTimeout(() => {\r\n          mediaRecorder.stop();\r\n        }, 10000);\r\n      } catch (error) {\r\n        console.error('Error recording audio:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  };\r\n  \r\n  export const initializeAudioStream = async (onDataAvailable) => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const mediaRecorder = new MediaRecorder(stream);\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          onDataAvailable(event.data);\r\n        }\r\n      };\r\n  \r\n      mediaRecorder.start(1000); // Send chunks every 1 second\r\n      return { stream, mediaRecorder };\r\n    } catch (error) {\r\n      throw new Error('Microphone access denied: ' + error.message);\r\n    }\r\n  };\r\n  \r\n  export const stopAudioStream = (mediaRecorder, stream) => {\r\n    if (mediaRecorder?.state === 'recording') {\r\n      mediaRecorder.stop();\r\n    }\r\n    stream?.getTracks().forEach(track => track.stop());\r\n  };\r\n\r\n  // Function to play audio\r\n  export const playAudio = (audioUrl) => {\r\n    const audio = new Audio(audioUrl);\r\n    audio.play();\r\n  };\r\n  \r\n  // Function to convert audio Blob to Base64\r\n  export const audioBlobToBase64 = (blob) => {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onloadend = () => {\r\n        resolve(reader.result.split(',')[1]); // Extract Base64 data\r\n      };\r\n      reader.onerror = reject;\r\n      reader.readAsDataURL(blob);\r\n    });\r\n  };"],"mappings":"AAAA;AACA,OAAO,MAAMA,WAAW,GAAGA,CAAA,KAAM;EAC7B,OAAO,IAAIC,OAAO,CAAC,OAAOC,OAAO,EAAEC,MAAM,KAAK;IAC5C,IAAI;MACF,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAC/C,MAAMO,WAAW,GAAG,EAAE;MAEtBF,aAAa,CAACG,gBAAgB,CAAC,eAAe,EAAGC,KAAK,IAAK;QACzDF,WAAW,CAACG,IAAI,CAACD,KAAK,CAACE,IAAI,CAAC;MAC9B,CAAC,CAAC;MAEFN,aAAa,CAACG,gBAAgB,CAAC,MAAM,EAAE,MAAM;QAC3C,MAAMI,SAAS,GAAG,IAAIC,IAAI,CAACN,WAAW,EAAE;UAAEO,IAAI,EAAE;QAAY,CAAC,CAAC;QAC9D,MAAMC,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC;QAC/Cd,OAAO,CAAC;UAAEc,SAAS;UAAEG;QAAS,CAAC,CAAC;MAClC,CAAC,CAAC;MAEFV,aAAa,CAACa,KAAK,CAAC,CAAC;;MAErB;MACAC,UAAU,CAAC,MAAM;QACfd,aAAa,CAACe,IAAI,CAAC,CAAC;MACtB,CAAC,EAAE,KAAK,CAAC;IACX,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9CtB,MAAM,CAACsB,KAAK,CAAC;IACf;EACF,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,MAAME,qBAAqB,GAAG,MAAOC,eAAe,IAAK;EAC9D,IAAI;IACF,MAAMxB,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MAAEC,KAAK,EAAE;IAAK,CAAC,CAAC;IACzE,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;IAE/CK,aAAa,CAACoB,eAAe,GAAIhB,KAAK,IAAK;MACzC,IAAIA,KAAK,CAACE,IAAI,CAACe,IAAI,GAAG,CAAC,EAAE;QACvBF,eAAe,CAACf,KAAK,CAACE,IAAI,CAAC;MAC7B;IACF,CAAC;IAEDN,aAAa,CAACa,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IAC3B,OAAO;MAAElB,MAAM;MAAEK;IAAc,CAAC;EAClC,CAAC,CAAC,OAAOgB,KAAK,EAAE;IACd,MAAM,IAAIM,KAAK,CAAC,4BAA4B,GAAGN,KAAK,CAACO,OAAO,CAAC;EAC/D;AACF,CAAC;AAED,OAAO,MAAMC,eAAe,GAAGA,CAACxB,aAAa,EAAEL,MAAM,KAAK;EACxD,IAAI,CAAAK,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEyB,KAAK,MAAK,WAAW,EAAE;IACxCzB,aAAa,CAACe,IAAI,CAAC,CAAC;EACtB;EACApB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE+B,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACb,IAAI,CAAC,CAAC,CAAC;AACpD,CAAC;;AAED;AACA,OAAO,MAAMc,SAAS,GAAInB,QAAQ,IAAK;EACrC,MAAMX,KAAK,GAAG,IAAI+B,KAAK,CAACpB,QAAQ,CAAC;EACjCX,KAAK,CAACgC,IAAI,CAAC,CAAC;AACd,CAAC;;AAED;AACA,OAAO,MAAMC,iBAAiB,GAAIC,IAAI,IAAK;EACzC,OAAO,IAAIzC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMwC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAC/BD,MAAM,CAACE,SAAS,GAAG,MAAM;MACvB3C,OAAO,CAACyC,MAAM,CAACG,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IACDJ,MAAM,CAACK,OAAO,GAAG7C,MAAM;IACvBwC,MAAM,CAACM,aAAa,CAACP,IAAI,CAAC;EAC5B,CAAC,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}